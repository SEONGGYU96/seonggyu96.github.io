---
layout: post
title: "Gradle"
subtitle: "빌드 자동화 툴"
author: "GuGyu"
header-style: text
tags:
  - Gradle
  - Build
---

안드로이드, 스프링 프레임워크를 통해 어플리케이션을 개발할 때, gradle 이라는 것을 만날 수 있다. 이들 프레임워크를 사용하기 위한 대부분의 입문 튜토리얼은 정확한 설명 없이 gradle에 사용할 모듈/라이브러리에 대한 플러그인이나 의존을 추가하라고만 한다. 꽤 경험이 있는 개발자들도 이를 정확히 모르고 있는 경우가 많기 때문에 한 번 정리해보려고 한다.  

gradle을 알기 전에, 간단히 알아둬야할 것들이 있다.  

- 빌드  
- 빌드 자동화
- DSL(Domain Specific Language)
- Groovy

## 빌드  

어플리케이션을 만드는 과정은 크게 컴파일 - 빌드 - 배포 과정을 따른다. 컴파일은 우리가 프로그래밍 언어로 작성한 코드를 기계어로 변환하는 작업이고 빌드는 기계어로 번환된 파일들을 엮어 실행 가능한 응용 프로그램 형태로 만드는 것이다. 그리고 마지막으로 배포는 이를 사용자들이 사용할 수 있는 환경(서버 등)에 배치시키는 과정을 말한다.  

보통은 컴파일을 포함한 배포하기 직전까지의 모든 과정을 "빌드 한다"라고 표현하기도 한다.

## 빌드 자동화  

사용하는 언어, 프레임워크, 만들고자 하는 최종 결과물에 따라 빌드 과정은 천차만별이다. 안드로이드를 예로 들어보면 다음과 같은 빌드 과정을 거친다.  

<img src="https://developer.android.com/images/tools/studio/build-process_2x.png?hl=ko"/>

1. 직접 작성한 코드 및 프레임워크 소스 코드들은 외부 라이브러리(AAR, JAR 등)과 함께 DEX(Dalvik Executable) 파일로 컴파일된다.  

2. APK Packager가 DEX파일과 컴파일된 리소스를 하나의 APK 파일로 결합한다.  

3. APK 파일에 서명한다.  

4. 최적화를 실행한다.  

이런 일련의 과정들은 어플리케이션의 규모가 커질 수록 굉장히 복잡해진다. 만약 프로그래머가 이 작업들을 직접 수행해야했다면 분명 사소한 실수들로 대부분의 빌드가 실패하거나 예상치 못한 에러를 일으킬 것이다. 

따라서 빌드 하고자 하는 환경 변수들(컴파일러, 버전 등)을 설정하고, 과정들을 코드로 미리 서술하여 빌드 과정을 자동화하였다. 이를 통해 프로그래머의 수고를 덜고, 믿을 수 있는 결과물을 생산할 수 있게 되었다.  

## DSL(Domain Specific Language)

DSL이란 특정 도메인(산업, 분야 등 특정 영역)에 **특화된** 언어를 말한다. 과일을 깎기 위해 위험하고 무거운 칼을 사용하지 말고, 과도를 사용하는 것을 떠올리면 DSL을 이해하기  쉽다. SQL, CSS, 정규식 등도 DSL의 한 종류라고 볼 수 있다.  

## Groovy  

Groovy는 Gradle에 특화된 DSL이다. 자바에 파이썬, 루비, 스몰토크 등의 특징을 더한 동적 객체 지향 프로그래밍 언어이다. 여기서 "동적" 이란, "동적 타이핑"을 뜻하며 런타임 시점에 새로운 타입을 생성할 수 있다(파이썬을 떠올리면 쉽다).  

가장 큰 특징으로는 JVM에서 동작한다는 것이다. 따라서 전반적으로 자바와 문법이 비슷한 경향이 있다.

## Gradle  

이제 본격적으로 Gradle에 대해 알아보자. Gradle은 앞서 알아본대로 Groovy를 기반으로 한 빌드 자동화 도구이다. 미리 정해진 규칙대로 소스 파일과 리소스 파일들을 배치해두면, 미리 정해진 과정대로 파일들을 빌드해준다.  

### 특징  

**간결함**  

Groovy 언어를 사용하기 때문에 XML을 사용하지 않아 장황하지않고 가독성이 좋다. 또한 변수 선언, if, else, for 등의 로직 구현이 가능하다.  

**속도**  

개발자라면 빌드에 뺏기는 시간이 은근 많다는 것을 알고 있을 것이다. Gradle은 성능 향상을 위해서 증분 빌드, 작업 결과 캐싱, 증분 하위 작업, 데몬 프로세스 재사용, 병렬 실행, 병렬 다운로드 등의 기능을 지원한다. 각 기능에 대한 자세한 내용은 [공식 홈페이지](https://gradle.org/features/)에서 확인할 수 있다.  


<b>멀티 프로젝트</b>  

Gradle은 멀티 프로젝트 구성이 가능하다. 즉, 하나의 프로젝트 폴더 내에 여러 개의 하위 프로젝트를 구성할 수 있다는 뜻이다. 굳이 하나의 폴더 안에 하위 프로젝트를 둘 필요가 없다고 느낄 수 있지만, 관련있는 프로젝트를 묶어두고 상위 프로젝트의 의존성 및 설정을 하위 프로젝트에서 상속받아 사용할 수 있다는 것은 규모가 큰 프로젝트에서 큰 메리트가 있다.  

<b>유연성 + 확장성</b>  

빌드 과정에서 실행하고 싶은 Task를 Groovy 언어로 직접 구현하고, 플러그인을 만들어 기능을 추가할 수도 있다. 이런 뛰어난 확장성과 유연함 덕분에 수많은 오픈소스 플러그인 생태계가 만들어졌다.  

<b>플러그인 생태계</b>  

Gradle에는 빌드 과정에서 동작하는 수많은 플러그인(checkstyle, pmd, findBugs, ...)이 있고, 이를 관리하고 있는 허브가 별도로 존재한다.

<br>  

### 디렉터리 구조  

Gradle은 미리 정해진 규칙대로 파일들을 빌드한다. 따라서 올바른 경로에 각종 빌드 세팅 파일, 소스/리소스 파일이 위치해있어야 한다. 이런 디렉터리 구조를 하나하나 직접 구축하는 것은 번거로우니 gradle이 설치되어 있다면, `gradle init` 명령어로 Gradle 프로젝트를 자동으로 생성할 수 있다.

<img src="https://user-images.githubusercontent.com/57310034/113285981-8f785380-9326-11eb-8f2a-2a7143f77e10.png"/>  

프로젝트 타입과 언어, 멀티 프로젝트 여부 등을 물어본다. 성심성의껏 대답하면(나는 application 프로젝트, Java 사용, 싱글 프로젝트, Groovy 사용, JUnit4 사용 으로 설정) 아래와 같은 디렉터리 및 파일들이 생성된다.  

<img width="450" src="https://user-images.githubusercontent.com/57310034/113287794-06165080-9329-11eb-9f28-94ea6160593f.png"/>  

`gradle init` 명령어를 통해서 최소한의 설정을 마친 후, 기본 값의 규칙과 빌드 과정을 서술해 알맞게 생성한 프로젝트이다. 어떤 규칙을 설정하는지, 어떤 빌드 과정을 따르는지에 따라 디렉터리 구조와 파일들을 얼마든지 바뀔 수 있다. 우선 기본 값으로 생성된 파일/폴더 등을 살펴보자.  

<img width="450" src="https://user-images.githubusercontent.com/57310034/113288698-41654f00-932a-11eb-9dc6-edacc30c243d.png"/>  

#### Project  

말 그대로 프로젝트에 대한 파일들을 포함한다. 최상위 디렉터리이기 때문에 빌드를 수행할 수 있는 파일과 설정 파일 등이 있다.  

**gradle폴더**  

Gradle wrapper를 위한 파일을 포함하고 있다. Graddle wrapper는 Gradle을 감싸고 있는 또 하나의 레이어라고 생각하면 된다. Gradle wrapper는 프로젝트를 빌드하기 위한 Gradle의 버전을 미리 정해두고, OS가 해당 버전의 Gradle이 설치되어 있지 않다면 다운로드하고, 설치되었다면 그것을 사용해 프로젝트를 빌드한다. 따라서 OS와 Gradle 버전에 구애받지 않고, 안정적이고 신뢰할 수 있는, 일관된 Gradle 버전으로 프로젝트를 빌드할 수 있다.

- `gradle-wrapper.jar`: Gradle distribution을 다운로드할 수 있는 JAR 파일
- `gradle-wrapper.properties`: Gradle wrapper의 런타임 동작 구성(ex. 이 프로젝트와 호환되는 Gradle 버전 등)을 설정하는 속성 파일

**gradlew**  

Unix 기반 OS에서 Gradle wrapper를 사용한 빌드를 위한 실행 스크립트이다. `gradle-wrapper.jar`, `gradle-wrapper.properties` 를 사용하여 실질적으로 프로젝트를 빌드할 수 있는 스크립트들을 실행한다.  

**gradlew.bat**  

Window OS에서 Gradle wrapper를 사용한 빌드를 위한 실행 스크립트이다.  

**settings.gradle**  

프로젝트의 설정 정보 파일이다. 프로젝트의 이름이나 프로젝트에 포함시킬 모듈이나 멀티 프로젝트 등을 설정하는 등의 역할을 한다.  

#### Application  

프로젝트에서 Application 모듈을 구성하는 파일과 폴더들을 포함한다.  

**build.gradle**

해당 Application 모듈을 빌드하기 위한 Gradle 설정 코드를 담고 있다.

**src**  

빌드의 대상이 되는 소스 코드와 리소스 파일들을 포함하고 있다.  

<br>

### Gradle Wrapper  

<img src="https://docs.gradle.org/current/userguide/img/wrapper-workflow.png"/>  

앞서 설명한대로 Gradle Wrapper는 Gradle을 한 번 감싼 외부 레이어로, 어떤 환경에서도 동일한 버전의 Gradle로 프로젝트를 빌드하는 **스크립트**이다. 위 이미지 처럼 프로젝트에 필요한 버전의 Gradle이 없다면 서버에서 다운로드하여 로컬 환경에 저장한다. 이후에는 로컬에 저장된 Gradle을 사용해 빌드를 수행한다.  

`gradle-wrapper.jar` 파일이 서버에서 특정 버전의 Gradle을 다운로드하는 역할을 하고 있으며, 어떤 버전이 필요한지는 `gradle-wrapper.properties`에 명시되어 있다.  

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-6.8.3-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
```  

`gradle-wrapper.properties`에 기본적으로 작성된 코드는 위와 같다.  

- distributionBase : Gradle이 설치되는 로컬 경로를 설정한다. 여기서는 `GRADLE_USER_HOME` 환경변수로 대체되어 있다.  
- distributionPath : 서버에서 다운로드한 Gradle 배포 버전을 저장할 상세 경로를 설정한다.  
- distributionUrl : 해당 프로젝트를 빌드할 때 필요한 Gradle 배포 버전을 다운로드 할 수 있는 URL을 설정한다.  
- zipStoreBase/Path : 다운로드한 Gradle 배포 버전의 zip 파일을 저장할 경로를 설정한다.  

Gradle Wrapper 를 사용해서 프로젝트를 빌드하기 위해서는 프로젝트 루트 경로에 위치한 `gradlew`(Unix)나 `gradlew.bat`(Window) 실행 파일을 사용해야한다.  

> \> ./gradlew  

그럼 `gradle-wrapper.properties`의 설정을 바탕으로 Gradle을 다운로드하거나 실행해 프로젝트를 빌드한다. 최초 1회 빌드 후에는 Gradle이 다운로드 되었기 때문에 빌드 시간이 훨씬 줄어들고, 만약 distributionUrl의 버전을 변경하면 해당 버전을 다시 다운로드해야하기 때문에 빌드 시간이 늘어나는 것을 확인할 수 있다.  

<br>

### 프로젝트 설정 및 모듈 임포트  

Gradle은 멀티 프로젝트/모듈을 지원한다. 위 예제에서 사용한 프로젝트도 루트 프로젝트 내에 App이라는 Application 모듈이 존재하는 구조이다. 따라서 루트 프로젝트의 `settings.gradle` 파일을 살펴보면 다음과 같은 코드가 작성되어 있다.  

```gradle
rootProject.name = 'gradle_test'
include('app')
```  

루프 프로젝트의 이름은 "gradle_test"로 설정하고, "app" 디렉터리를 포함시키겠다고 설정되어있다. 즉 "app" 모듈을 빌드에 포함시키겠다는 말이다.  

`settings.gradle`은 이렇게 프로젝트의 정보를 설정하고 하위 프로젝트/모듈들과의 관계를 서술하는 역할을 한다. "app" 모듈 말고도 다른 프로젝트/모듈을 생성해 관계를 맺고, 빌드 구성을 상속하는 등 다양한 설정이 가능하다.  

### 의존성 관리  

프로젝트를 개발하다보면 외부 라이브러리, 모듈을 임포트해 사용한다. 프로젝트 규모에 따라 수십, 수백개의 라이브러리, 모듈들이 필요한데 이를 하나하나 JAR 파일로 다운로드 받으려면 꽤 많은 시간이 필요할 것이다. 또한 다른 PC에서 프로젝트를 빌드하려면 모든 JAR 파일들도 함께 옮겨야한다.  

Gradle은 외부 라이브러리, 모듈에 대한 정보를 작성해두면 빌드 과정에서 이들을 모두 다운로드 받아 프로젝트에 포함시켜준다.  

프로젝트나 모듈을 빌드하기 위한 설정을 하는 파일은 `build.gradle` 이라고 했다. 여기에는 다음과 같은 코드를 작성할 수 있다.  

```gradle  
dependencies {
    implementation "org.springframework:spring-context:5.0.2.RELEASE"
    implementation "org.springframework:spring-jdbc:5.0.2.RELEASE"
    implementation "org.apache.tomcat:tomcat-jdbc:8.5.27"
    implementation "mysql:mysql-connector-java:5.1.45"
    implementation "org.slf4j:slf4j-api:1.7.25"
}
```  

`dependencies`라는 스코프 안에 `implementation`을 사용하여 스프링 프레임워크와 톰캣, mysql 등을 추가해달라고 선언하는 코드이다.  

큰 따옴표 안에 들어가는 정보는 다음과 같은 형식으로 이루어져있다.  

`package:name:version`  

즉 "org.springframework:spring-context:5.0.2.RELEASE" 는 org.springframework 패키지의 spring-context 모듈을 5.0.2.RELEASE 버전으로 다운로드 받아 사용하겠다는 의미이다.  

필요한 라이브러리의 패키지와 이름, 버전은 알았는데 그럼 이들을 정확히 어디서 다운받는걸까? `build.gradle`에는 다음과 같은 코드도 함께 추가되어있다.  

```gradle
repositories {
    mavenCentral()
}
```  

dependencies에 선언된 라이브러리와 모듈을 다운로드 받는 repostories 를 설정하는 부분이다. 여기서는 `mavenCentral()` 메서드를 사용해 Maven Central Repository에서 다운로드하도록 설정했다.  

그럼 결과적으로 `implementation "org.springframework:spring-context:5.0.2.RELEASE"` 를 선언함으로써 [https://mvnrepository.com/artifact/org.springframework/spring-context/5.0.2.RELEASE](https://mvnrepository.com/artifact/org.springframework/spring-context/5.0.2.RELEASE) 에서 라이브러리를 다운로드받아 프로젝트에 추가한다.  

<br>

## 빌드 과정  

Gradle이 어떤 특징을 가지는지, 어떤 디렉터리 구조를 가지는지 알았다. 외부 의존성을 런타임에 어디서 다운로드 받아 추가해주는지도 알았다. 그렇다면 정확히 내가 작성한 소스 코드를 어떻게, 어떤 과정으로 빌드를 하는걸까? Gradle이 빌드를 어떻게 수행하는지 알기 위해서는 다음 개념들을 먼저 알아야한다.  

- Task
- Project
- Plugin

### Task  

Gradle이 빌드를 어떻게 수행하는지 알기 위해서는 Task에 관한 개념을 먼저 알아야한다. Gradle은 빌드 과정을 Task 단위로 수행한다. 즉 Task는 더 이상 쪼갤 수 없는 원자성을 띄는 단위이다. 소스 코드를 컴파일하거나 Unit Test를 실행하고, JAR 로 압축하는 과정 등 더이상 쪼갤 수 없는 작업 과정을 하나의 Task 에 구현한다. 

Task는 다음과 같이 생성할 수 있다.  

- task myTask
- task myTask { configure closure }
- task myTask(type: SomeType)
- task myTask(type: SomeType) { configure closure }  

예를 들어 두 번째 형태를 사용해서 다음과 같은 Task를 선언할 수 있다.  

```gradle
task hello {
    println 'Hello World!'
}
```  

#### Task Action  

Task는 Action 객체들의 나열로 이루어져있다. 각 Action들은 `Action.execute(T)` 로 실행되며 `Task.doFirst(Action or closure)`, `Task.doLast(Action or closure)`을 사용해서 Action의 실행 순서를 명시적으로 결정할 수 있다.  

```gradle
task hello {
    doFirst {
        println 'Hello World!'
    }
    println 'I am Gradle'
    doList {
        println 'Nice to meet you!'
    }
}
``` 

Action은 2가지 예외를 던질 수 있다.  

- StopActionException : 예외가 발생한 Action을 abort하고 다음 Action을 수행한다.
- StopExecutionException : 예외가 발생한 Action이 포함된 Task를 abort하고 다음 Task를 수행한다.  

#### Task Dependencies, Ordering  

Task는 각 Task끼리 의존(서로를 실행)하거나 어떤 Task가 끝나면 항상 실행되도록 스케줄링을 할 수도 있다. Gradle은 Task가 명시한 실행 순서를 지켜 각 Task들을 실행시킨다.  

- Task.dependsOn(java.lang.Object[])
- Task.setDependsOn(java.lang.Iterable)
- Task.mustRunAfter(java.lang.Object[])
- Task.setMustRunAfter(java.lang.Iterable)
- Task.shouldRunAfter(java.lang.Object[])
- Task.setShouldRunAfter(java.lang.Iterable)  

위와 같은 다양한 메서드를 지원하기 때문에 유연한 Task 실행 순서를 설계할 수 있다.  

#### Method  

Task에는 Action 뿐만 아니라 일반 메서드도 포함시킬 수 있다. 메서드 선언은 자바 문법과 동일하다.  

```gradle
task hello {
    prntMessage 'Hello World!'
}

String printMessage(String msg) {
    println msg
}
```  

Task는 이렇게 Action과 메서드들로 이루어져있고, 이런 Task들을 논리적인 순서로 수행하며 프로젝트의 빌드가 진행된다.  

### Project  

Prject는 빌드 파일(build.gradle 등)이 실제 Gradle과 상호작용하기 위한 메서드들을 포함하는 인터페이스이다. 우리는 Prject의 메서드를 잘 조작하여 Gradle의 기능에 접근해야한다.  

Project는 build.gradle과 1:1 대응된다. 즉 build.gradle 파일 하나당 Project 인스턴스 하나를 생성한다. Project 인스턴스가 생성되는 과정은 다음과 같다.  

1. Setting 인스턴스를 생성한다.  
1-1. setting.gradle 스크립트가 존재하면, 이에 따라서 인스턴스를 생성한다.  
2. 생성된 Setting 인스턴스에 따라 Project 인스턴스를 생성하고 계층화한다. (하위 프로젝트/모듈 연결)  
3. build.gradle 파일에 의해 각 Project 인스턴스의 메서드를 실행한다. 최상위 Project 부터 실행된다.  

Project 에 정의된 대표적인 프로퍼티는 다음과 같다.  

- allprojects : 해당 프로젝트와 하위 프로젝트들의 Set  
- dependencies : 해당 프로젝트의 의존성을 관리하는 DependencyHandler 인스턴스  
- repositories : 선언된 의존성들을 다운로드 하거나, 해당 프로젝트로 생성한 artifact 를 업로드할 레포지토리를 생성하는 핸들러 인스턴스  
- rootProject : 프로젝트 계층에서 최상위 프로젝트 인스턴스를 가리킴  
- subprojects : 하위 프로젝트들의 Set  
- tasks : 해당 프로젝트의 task들  
- version : 해당 프로젝트의 버전 정보  

다음은 대표적인 메서드들이다.  

- allprojects(closure) : 해당 프로젝트와 모든 하위 프로젝트에서 클로저를 실행  
- apply(closure) : 플러그인 추가 (0 ~ n개)  
- subprojects(closure) : 모든 하위 프로젝트에서 클로저를 실행  

### Plugin  

플러그인은 새로운 Task를 추가하거나 적합한 기본 값으로 Task를 설정한다. 그리고 의존성을 추가하거나 기존 타입에 다른 프로퍼티나 메서드를 추가하는 등 전체적인 빌드 과정을 튜닝하는 역할을 한다.  

따라서 플러그인을 build.gradle에 추가하면 해당 build.gradle과 매칭되는 Project 인스턴스는 기존에는 없던 Task나 메서드들을 가지거나 수정된 형태를 사용할 수 있다.  

예를 들어 'java' 플러그인을 추가하면 Project에는 다음과 같은 프로퍼티가 추가된다.  

- distsDirectory : TAR, ZIP 결과물이 저장될 디렉터리
- sourceSets : 소스 코드들의 컨테이너  

추가되는 메서드 

- manifest(closure) : Manifest 인스턴스를 생성하고 주어진 closure로 설정한다. 

(이 외에도 다양한 프로퍼티와 메서드가 추가된다)  

---  

Task와 Project, Plugin을 알아봤으니 이제 빌드 과정을 살펴보도록 하자. 이제 build.gradle의 모든 코드를 이해할 수 있고, Gradle에 대한 의문점들을 대부분 해소할 수 있다. 가볍게 다음 질문에 답해보자.

Gradle은 Java는 물론 Kotlin, Swift, C++ 등 다양한 언어를 빌드할 수 있다. 각 언어마다 빌드하기 위한 컴파일러도 다르고 과정도 다른데 어떻게 구분해서 빌드해주는걸까?  

정답은 플러그인이다. build.gradle에 다음과 같이 플러그인을 추가함으로써 Gradle 빌드 과정을 튜닝시켰다.  

```gradle
apply {
    id 'java'
    id 'kotlin-android'
    id 'kotlin-kapt'
}
```  

이 build.gradle과 매칭되는 Project는 java와 안드로이드의 kotlin을 빌드할 수 있게 되었다. 우리는 복잡한 튜닝 과정을 미리 서술해놓은 플러그인을 적용해주기만 하면 된다.  

플러그인을 적용하기 위한 apply 메서드는 위에서 설명한대로 Project 인터페이스에 정의되어 있는 메서드이다. 즉, 우리는 Gradle에게 "Java와 Kotlin을 빌드할 수 있도록 튜닝해줘" 라는 요청을 하기 위해 Gradle과 build.gradle을 이어주는 Project API를 사용한 것이다.  

그럼 이제 다음과 같은 build.gradle 코드를 보자.  

```gradle
plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'kotlin-kapt'
}

android {
    compileSdkVersion 30
    buildToolsVersion "30.0.2"

    defaultConfig {
        applicationId "com.example.gradletest"
        minSdkVersion 23
        targetSdkVersion 30
        versionCode 1
        versionName "1.0.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    ...
```  

android 라는 메서드는 Project에 기본적으로 정의된 메서드가 아니였다. 이는 어디서 나온 것일까? 우리는 "com.android.application" 이라는 플러그인으로부터 새롭게 추가된 메서드임을 추측할 수 있다. 해당 플러그인을 적용함으로써 빌드 과정은 안드로이드 어플리케이션을 산출해내도록 튜닝되었고, 그 과정에서 각종 설정을 더할 수 있는 android 메서드를 추가한 것이다.    

또한 defaultConfig 와 같은 하위 블럭들도 추가되었는데, 플러그인을 추가함으로써 정확히 어떤 구성요소들이 추가되는지는 해당 플러그인 명세를 살펴보면 된다.  

[Android Plugin DSL Reference](https://google.github.io/android-gradle-dsl/3.4/index.html#N10009)를 살펴보면 다음과 같은 내용을 확인할 수 있다.  

<img src="https://user-images.githubusercontent.com/57310034/113468958-99b06400-9484-11eb-94f5-180cc84fef4c.png"/>  

<br>

## 마무리  

이처럼 Gradle을 사용하면 다양한 언어, 다양한 프레임워크의 빌드 과정을 자동화할 수 있다. 각 언어, 프레임워크를 빌드하기 위한 플러그인은 이미 잘 작성되어 존재하니 우리는 이를 적용해주기만 하면 된다. 만약 생소한 메서드나 블럭이 보이면 추가한 플러그인의 명세를 살펴보고 목적에 맞게 활용하면 된다.  

뿐만 아니라 빌드 과정에서 특정 작업을 끼워넣고 싶다면 Task를 프로젝트에 직접 추가해도 되고, 이들을 플러그인으로 만들어두고 여러 프로젝트에 적용할 수도 있다. 앞으로 Gradle을 조금 더 다양하고 유연하게 활용해보도록 하자.  


<br>
<br>


--- 
참고:  
[컴파일, 빌드, 배포](https://itholic.github.io/qa-compile-build-deploy/)  
[빌드 자동화](https://choicurly.tistory.com/entry/%EB%B9%8C%EB%93%9C-%EC%9E%90%EB%8F%99%ED%99%94%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)  
[DSL](https://unabated.tistory.com/entry/DSLDomain-Specific-Language-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)  
[아파치 그루비](https://ko.wikipedia.org/wiki/%EC%95%84%ED%8C%8C%EC%B9%98_%EA%B7%B8%EB%A3%A8%EB%B9%84)  
[Graddle Wrapper](https://docs.gradle.org/current/userguide/gradle_wrapper.html)  
[Graddle Wrapper2](https://goateedev.tistory.com/133)  
[Task](https://madplay.github.io/post/what-is-gradle)  
[Task2](https://docs.gradle.org/current/dsl/org.gradle.api.Task.html)  
[Project](https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N155F5)

