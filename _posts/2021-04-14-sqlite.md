---
layout: post
title: "안드로이드 : SQLite"
subtitle: "DB락, Helper"
author: "GuGyu"
header-style: text
tags:
  - Android
  - AndroidFramework
  - ContentProvider
  - DB
  - SQLite
---

이번 포스팅에서는 콘텐트 프로바이더에서 주로 데이터 소스로 사용하는 SQLite를 살펴보고 관련 세부 내용과 이슈들을 알아보도록 하자.  

# SQLite  

SQLite는 로컬 DB이지만 속도가 그렇게 빠르지는 않다. 딱 혼자서 쓸 수 있는 정도이다. SQLite는 네이티브 라이브러리에 포함되어 있고 프레임워크를 거쳐서 접근하고 사용한다.  

## 1. DB 내용 확인  

SQLite db 파일은 `/data/data/패키지/databases`에 저장된다. 루팅한 단말기가 아니라면 db 파일에 직접 접근하거나 쿼리를 실행할 수 없다. 개발 시에 에뮬레이터에서 db를 확인하는 방법은 세 가지가 있다.  

- sqlite shell 에서 쿼리를 실행한다.  
- `adb pull` 을 통해 db 파일을 가져와서 SQLite Database Browser 같은 툴로 데이터를 확인하고 쿼리를 실행한다.  
- 안드로이드 스튜디오에서 제공하는 Database Inspector 를 사용한다.  

## 2. DB 파일 목록 조회  

adb shell 에서 모든 db 파일 목록을 `ls -R /data/data/*/databases` 명령으로 확인할 수 있다.  

```
/data/data/com.android.dialer/databases:
dialer.db  dialer.db-journal

/data/data/com.android.keychain/databases:
grants.db  grants.db-journal

/data/data/com.android.mtp/databases:
database  database-journal

/data/data/com.android.providers.calendar/databases:
calendar.db  calendar.db-journal

/data/data/com.android.providers.contacts/databases:
calllog.db  calllog.db-journal  contacts2.db  profile.db  profile.db-journal

/data/data/com.android.providers.downloads/databases:
downloads.db  downloads.db-journal

/data/data/com.android.providers.media/databases:

/data/data/com.android.providers.telephony/databases:
mmssms.db  mmssms.db-journal

/data/data/com.android.providers.userdictionary/databases:
user_dict.db  user_dict.db-journal

/data/data/com.android.service.ims.presence/databases:

/data/data/com.google.android.apps.docs/databases:
-1_inbox_threads.notifications.db  -1_inbox_threads.notifications.db-journal  -1_threads.notifications.db  -1_threads.notifications.db-journal  DocList.db  DocList.db-shm  DocList.db-wal  accounts.notifications.db  accounts.notifications.db-journal  google_analytics_v4.db  google_analytics_v4.db-journal  growthkit.db

/data/data/com.google.android.apps.maps/databases:
gmm_sync.db  gmm_sync.db-journal  google_app_measurement_local.db  google_app_measurement_local.db-journal  ue3.db  ue3.db-journal

/data/data/com.google.android.apps.messaging/databases:
bugle_db  bugle_db-shm  bugle_db-wal  google_app_measurement_local.db  google_app_measurement_local.db-journal  growthkit.db  undelivered_messages  undelivered_messages-journal

/data/data/com.google.android.apps.nexuslauncher/databases:
app_icons.db  app_icons.db-journal  launcher.db  launcher.db-journal  widgetpreviews.db  widgetpreviews.db-journal

/data/data/com.google.android.apps.photos/databases:
gphotos-1.db  gphotos-1.db-shm  gphotos-1.db-wal  media_store_extras  media_store_extras-shm  media_store_extras-wal

/data/data/com.google.android.apps.pixelmigrate/databases:
crash_reports  crash_reports-journal

/data/data/com.google.android.apps.restore/databases:
crash_reports  crash_reports-journal

...
```  

만약 권한이 없다는 에러가 발생하면 `adb root` 명령어를 먼저 실행한 다음 다시 입력해보면 된다. 그럼에도 불구하고 "adbd cannot run as root in production builds" 에러가 발생한다면 실기기 말고 가상 에뮬레이터를 사용해보자.  

아무튼 /data/data 아래에서 프로세스명 위치에 providers가 들어가는 것들을 보면 콘텐트 프로바이더에서 어떤 DB를 사용하는지 볼 수 있다. 단말기에 설치된 기본 앱(캘린더, 주소록 등)이나 미디어 데이터, 시스템 설정 등도 콘텐트 프로바이더를 제공하는데, 안드로이드에서 제공하는 콘텐트 프로바이더는 [android.provider](https://developer.android.com/reference/android/provider/package-summary) 패키지에서 확인할 수 있다.  

위 파일 목록들을 살펴보면 db 확장자 외에도 db에 -journal, -wal, -shm 등이 붙은 확장자 파일을 볼 수 있다. 이것은 SQLite에서 트랜잭션(atomic commit and rollback)을 구현한 방식에 따른 것이다. 디폴트는 rollback-journal (-journal 파일 사용)이고 다른 옵션으로 Write-Ahead Logging(보통 WAL이라 쓰고 -wal과 -shm 파일 사용)이 있다.  

## 3. sqlite shell  

sqlite shell을 통해 시스템 설정이 어떤 테이블로 구성되어있는지 확인해보자. (단발기기의 종류에 따라 경로나 결과 출력이 다를 수 있다.)  

<img width="600" src="https://user-images.githubusercontent.com/57310034/113553052-13398500-9632-11eb-9fb9-4cb33e6a3301.png"/>  

### 3-1 닷 커맨드  

sqlite shell에서는 SQLite 닷 커맨드라고 불리는 명령어 모음이 있다. 말 그대로 닷(.)으로 시작하고 다른 명령어처럼 세미콜론을 쓰지 않는다.  

<b>테이블 목록 보기</b>  

<img width="400" src="https://user-images.githubusercontent.com/57310034/113554073-b76ffb80-9633-11eb-89a6-2cbf6bf0f42e.png"/>

<br>

<b>스키마 확인</b>  

<img width="600" src="https://user-images.githubusercontent.com/57310034/113554266-0a49b300-9634-11eb-8e8c-254a26914205.png"/>  

<br>

<b> 조회할 때 칼럼명 헤더를 보는 옵션</b>  

on/off 옵션을 쓸 수 있고 디폴트는 off이다.  

`sqlite> .headers on`  

### 3-2. 데이터베이스 명령어 실행  

sqlite shell에서 다양한 데이터베이스 명령어를 실행할 수 있다. 계속해서 system 과 global 테이블을 조회해보자.  

<img width="600" src="https://user-images.githubusercontent.com/57310034/113554571-788e7580-9634-11eb-9160-cc47581fe96e.png"/>  

<img width="700" src="https://user-images.githubusercontent.com/57310034/113555510-01f27780-9636-11eb-9afc-ead11ce684e5.png"/>  

위 내용은 시스템 환경 설정 값들이다. [Settings.System](https://developer.android.com/reference/android/provider/Settings.System#constants)클래스의 문자열 상수가 위 테이블들의 name 칼럼에 있는 값과 동일하다는 것을 알 수 있다.  

sqlite shell에서 쓸 수 있는 명령어 모음은 아래 사이트를 참고할 수 있다.  

- [https://www.sqlite.org/lang.html](https://www.sqlite.org/lang.html)  
- [https://www.tutorialspoint.com/sqlite/index.htm](https://www.tutorialspoint.com/sqlite/index.htm)  

### 3-3. PRAGMA 명령어  

PRAGMA 명령어는 DB의 환경 변수나 상태 플래그를 가져오거나 변경할 때 사용한다. SQLiteDatabase에는 `getVersion()` 메서드가 있는데 아래 명령어의 결과를 가져온다.  

`> PRAGMA user_version`  

SQLite에서 지원하는 언어 중에서 C API를 보면 다양한 함수가 있는데 안드로이드의 SQLiteDatabase 클래스에는 메서드 개수가 많지 않다. 그나마 여기에 도움을 주는 것이 PRAGMA 명령어라고 보면 된다. PRAGMA 명령어를 써서 앱의 환경에 맞는 튜닝도 가능하다. 해당 방법은 [여기](https://www.tutorialspoint.com/sqlite/sqlite_pragma)을 참조하자.  

## 4. DB 락 문제  

앱에서 SQLite를 사용할 때 가장 문제가 되는 것은 DB 락이다. 일반적으로 DB 명령은 백그라운드 스레드에서 실행하는 것이 권장된다. DB 락 문제는 스레드 간 (또는 프로세스 간) 명령을 실행할 때 락을 잡는 시점이 겹치면서 발생한다. 이때, `SQLiteDatabaseLockedException`을 발생시킨다.  

### 4-1. 5가지 락 상태  

락의 기본 원칙은 DB에 쓸 때는 배타 락(exclusive lock)을 잡고, 읽을 때는 공유 락(shared lock)을 잡는다는 것이다. 배타 락은 말 그대로 다른 락을 허용하지 않고, 공유 락은 다른 공유 락과 함께 공존할 수 있다.  

락 상태에는 아래의 5가지가 있다. 이는 프로세스나 스레드 모두에 해당하는 것이다.  

#### UNLOCKED  

읽기와 쓰기가 불가능한 기본 상태  

#### SHARED

읽기만 가능한 상태. 여러 프로세스가 동시에 읽을 수 있다. 하나 이상의 공유 락이 활성화되어 있다면, 다른 프로세스에서 쓰기를 할 수 없다.  

#### RESERVED

프로세스가 미래 어느 시점에 쓰기를 한다는 일종의 플래그 락이다. 예약 락은 하나만 있을 수 있으며, 여러 공유 락과 공존할 수 있다.  

#### PENDING

락을 잡고 있는 프로세스가 가능한 한 빨리 쓰기를 하려고 시도하는 상태. 현재의 모든 공유 락이 해제될 때까지 기다려서 배타 락을 가지려고 한다. 이 상태에서는 새로운 공유 락을 잡을 수 없다.  

#### EXCLUSIVE

파일을 쓰기 위한 상태. 오직 하나의 프로세스만 가질 수 있고 다른 락과 공존할 수 없다. SQLite에서는 동시성을 높이기 위해서 배타 락을 잡는 시간을 최소화하고 있는데, 우리도 배타 락 구간을 줄이도록 코드를 짜야한다.  

### 4-2. DB 락의 발생 원인  

DB 락이 발생하는 원인은 CRUD (create, read, update, delete) 가운데 CUD에서 쓰기를 하면서 배타 락을 잡는 것 때문이다. 쿼리가 단순한 경우에는 짧은 시간만 락이 잡히기 때문에 문제가 빈번하게 발생하지는 않는다. 가장 락을 오래 잡는 경우는 쓰기를 한꺼번에 하는 트랜잭션이다.  

### 4-3. 트랜잭션 동작 방식  

SQLite에서 트랜잭션은 지연(deferred), 즉시(immediate), 배타(exclusive)의 3가지 동작 방식(behavior)를 사용한다. 디폴트는 deferred이다.  

#### deferred  

락을 가능한 한 뒤로 미룬다. 트랜잭션을 시작할 때는 락을 잡지 않는다. 첫 읽기 작업이 있을 때 공유 락을 잡고, 첫 쓰기 작업이 있을 때 예약 락을 잡는다.  

#### immediate  

트랜잭션을 시작할 때 예약 락이 잡힌다. 곧 쓰기 작업을 할 것이라고 예고하는 것이다. 예약 락은 2개 이상 잡힐 수 없으므로, 다른 immediate 트랜잭션을 시작할 수는 없다. 그래도 다른 프로세스나 스레드에서 읽기를 할 수는 있다.  

#### exclusive  

트랜잭션을 시작할 때부터 배타 락이 잡힌다. 따라서 트랜잭션의 시작부터 끝까지 다른 프로세스나 스레드에서 DB 작업을 전혀 할 수 없다.  

<br>  

하지만 안드로이드에서 지원하는 것은 immediate와 exclusive 두 가지 뿐이다. 게다가 immediate는 허니콤부터 지원하기 시작했다. 실제로, [공식문서](https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html)를 살펴보면 deferred 를 사용한 트랜잭션 메서드나 상수 등을 찾아볼 수 없다. SQLite 사이트에는 deffered가 디폴트이고 이 기준으로 쓰여있는 문서들이 있어서 혼동되는 경우가 있다. 주의해서 보도록 하자.  

### 4-4. 트랜잭션 사용 방법  

SQLiteDatabase에서 트랜잭션을 쓰는 패턴은 아래와 같다. 원래 `beginTransaction()` 메서드를 사용했으나 허니콤부터 `beginTransactionNonExclusive()` 메서드도 사용 가능하며, immediate 방식으로 트랜잭션을 시작한다.  

```java
if (Build.VERSION.SDK_INT >= Build.VERSION_CODE.HONEYCOMB) {
    db.beginTransactionNonExclusive();
} else {
    db.beginTransaction();
}
try {
    ...
    db.setTransactionSuccessful();
} catch (Exception e) {
    ...
} finally {
    db.endTransaction();
}
```

### 4-5. DB 락 문제 테스트  

단말기에서 DB 락 에러를 재현하는 것은 쉽지 않다. 특히 최신 단말에서는 더욱 어려운데, 당장 눈에 보이지 않는다고해서 다른 사용자 단말에서도 문제가 없다고 생각해서는 안된다. 아무튼 DB 락 문제는 테스트를 통해 케이스별로 해결할 수 있는 것이 아니다. DB 락 문제가 발생하지 않으려면 원인을 알고 원칙적으로 접근해야만 한다.  

### 4-6. 락/트랜잭션 샘플 테스트  

락/트랜잭션 관련해서 테스트 샘플 코드는 [여기](https://github.com/kpgalligan/Android-Database-Locking-Collisions-Example) 에서 찾을 수 있다.  

이 샘플에서는 catch 문에서 예외를 잡기 때문에 DB 락으로 인한 크래시가 발생하지 않는다. 테스트에서 입력된 데이터 개수가 정해진 숫자보다 적으면 그만큼 DB 락 문제가 생긴 것이다.  

1. 여러 스레드에서 1개의 SQLiteDatabase 인스턴스만 가지고 쓰기를 한다. 이때는 DB 락이 발생하지 않는다. 스레드의 개수를 메모리 한계까지 늘려도 DB 락은 발생하지 않는다.

2. 여러 스레드에서 각각 SQLiteDatabase 인스턴스를 가지고 쓰기를 한다. 이때는 DB 락이 발생한다. 스레드 수를 늘릴 수록 DB 락의 발생 빈도가 높아진다.  

3. 1개의 스레드에서 1개의 SQLiteDatabase 인스턴스를 가지고 계속 쓰기를 하고, 여러 스레드에서 각각 SQLiteDatabase 인스턴스를 가지고 읽기만 한다면 DB 락이 발생한다.  

4. 여러 스레드에서 각각 SQLiteDatabase 인스턴스를 가지고서 읽기만 하면 DB 락이 발생하지 않는다.  

5. 1개의 SQLiteDatabase 인스턴스를 가지고 쓰기 트랜잭션과 읽기를 동시에 실행하면 DB 락이 발생하지 않는다.  

6. SQLiteDatabase에 많은 데이터를 쓸 때 트랜잭션으로 감싼 경우와 그렇지 않는 경우를 비교한다. 트랜잭션을 쓰는 경우에 시간이 크게 줄어드는 것을 볼 수 있다.  

1 ~ 5번의 테스트에서 중요한 것은 SQLiteDatabase 인스턴스를 1개만 가지고 여러 스레드에서 DB 명령을 실행해도 DB 락이 발생하지 않는다는 점이다. 이것은 SQLite의 [기본 스레딩 모드(default threading mode)](https://www.sqlite.org/threadsafe.html)가 직렬(serialized)이기 때문이다. 즉 명령어들이 순차적으로 실행된다.  

결국 DB 락 문제 해결은 단순해진다. 케이스별로 확인하는 것이 아니라 SQLiteDatabase 1개의 인스턴스를 유지하기만 하면 된다.  

### 4-7. 읽기 전용 DB  

그러나 여러 스레드에서 DB 명령을 실행할 때 SQLiteDatabase 인스턴스를 1개만 사용하는 방식은 여러 개를 사용하는 것보다 당연히 느리다. DB 락 문제를 막기위해선 어쩔 수 없을까?  

여러 스레드에서 읽기만 한다면 여러 인스턴스를 사용해도 된다는 것을 위 테스트를 통해 알아냈다. 이를 응용해보자. 만약 캘린더 앱에서 공휴일 데이터 같은 것은 한번 일괄적으로 쓰고 나서 다시 변경할 일이 없다. 이때 공휴일 데이터는 읽기와 쓰기가 필요한 다른 데이터와 동일한 DB에 두지말고, 별도의 읽기 전용 DB에 두는 것이 좋다. 여러 스레드에서 읽기 전용 DB에 접근할 때 각각 별도의 SQLiteDatabase 인스턴스를 가지고 읽기 명령을 실행해도 DB 락 문제없이 동시 실행이 가능하다.  

## 5. SQLiteOpenHelper 클래스  

SQLiteDatabase는 SQLite에 접근하는 클래스로, SQL 명령어를 실행하고 DB를 관리하는 메서드를 가지고 있다. 그러나 SQLiteDatabase를 직접 생성하고 접근해서 사용하는 경우는 드물다. 대부분의 경우 Room을 사용하거나 SQLiteOpenHelper를 상속해서 사용한다. 일반적으로 앱이 업데이트됨에 따라 DB의 논리적 구조가 변경되곤 한다. 그래서 버전 관리는 필수적인데, Room이나 SQLiteOpenHelper는 이를 알아서 해준다.

여기서는 SQLiteOpenHelper를 위주로 살펴보자. SQLiteOpenHelper는 추상 클래스이면서 일종의 템플릿 메서드 패턴을 만들어 놓은 것으로, 이 클래스를 상속해서 `onCreate()`와 `onUpgrade()` 메서드를 구현하면 된다.  

```java
public class DatabaseHelper extends SQLiteOpenHelper {
    private static final String DATABASE_NAME = "loader_throttle.db";
    private static final int DATABASE_VERSION = 2;

    DatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABSE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabse db) {
        db.execSQL("CREATE TABLE " + MainTable.TABLE_NAME + " ("
            + MainTable._ID + " INTEGER PRIMARY KEY,"
            + MainTable.COLUMN_NAME_DATA + " TEXT" + ");");
        ...
    }

    @Override
    public void onUpgrade(SQLiteDatabse db, int oldVersion, int newVersion) {
        for (int i = oldVersion + 1; i <= mewVersion; i++) {
            processUpgrade(db, i);
        }
    }
}
```  

### 5-1. DB 헬퍼의 운용 개수  

위 DB 헬퍼 코드를 보면 DB 파일명을 설정하고 있다. 따라서 DB을 여러 개 쓴다면 헬퍼도 여러 개 필요하다. 앞서 DB 락 문제를 해결하기 위한 방법으로 읽기 전용 DB를 분리할 수 있다고 했는데, 이 경우에도 헬퍼를 각각 만들어주어야 한다.  

그러나 테이블과 데이터 구조가 동일한 여러 DB가 있다면 헬퍼를 하나만 사용할 수 있다. 예를 들어 로그인 기반의 앱이라면, 공통으로 사용하는 데이터를 위한 공통 DB가 있고 각 사용자별 DB가 있을 수 있다. 각 사용자별 DB는 당연히 테이블 구조가 동일하다. 이때는 DB 파일명을 상수로 만들지 않고 동적으로 전달하면 된다.  

```java
DatabaseHelper(Context context) {
    super(context, getAuth().getLoginId() + ".db", null, DATABASE_VERSION);
}
```  

### 5-2. DB 생성 시점  

DB는 어느 시점에 생성될까? SQLiteOpenHelper 생성자에서 생성된다고 생각하기 쉬우나 그렇지 않다. SQLiteOpenHelper의 `getReadableDatabase()`나 `getWritableDatabse()` 메서드를 호출할 때 실제로 DB를 열거나 생성한다. 더 정확하게 이야기하자면, SQLiteOpenHelper에는 SQLiteDatabase 인스턴스를 1개 가지고 있는데 이 인스턴스가 앞에 이미 생성되었으면 그것을 사용한다. 인스턴스가 생성된 게 없을 경우에는 인스턴스를 새로 생성하고서 `onCreate()`나 `onUpgrade()`를 실행한다.  

### 5-3. DB 버전 업그레이드  

DB 테이블 변경 시에는 DatabaseHelper 생성자에 새로운 버전을 전달하고, SQLiteOpenHelper의 `onUpgrade()` 메서드에 변경 내용을 적용해야한다. 이때 표준 패턴은 다음과 같이 oldVersion과 newVersion 범위 사이에 DB 버전에 했던 작업들을 일괄 처리하는 것이다.  

```java
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    for (int i = oldVersion + 1; i <= newVersion; i++) {
        processUpgrade(db, i);
    }
}
```  

DB 스키마가 변경될 때는 **반드시** DB 버전 업그레이드가 필요하다. 만약 테이블 설계에 오류가 있는 DB 버전이 배포가 되었다고 하자. 테이블 변경 명령을 다시 작성해서 DB 버전을 동일하게 하면 편하지만 기존에 오류가 있는 DB 버전을 사용하고 있던 단말에서는 문제가 발생한다. 버전 값이 변경된 것은 없기 때문에 `onUpgrade()`는 실행되지 않고 업데이트된 테이블을 사용할 수 없다. 따라서 정상적인 방법으로 DB 버전을 올리고서 onUpgrade()에서 테이블 구조를 변경할 수 있게 해야한다.

### 5-4. onCreate(), onUpgrade()  

`onCreate()`메서드에서는 최신 DB 스키마와 데이터를 반영해야한다. onCreate() 메서드는 앱이 처음 DB를 생성할 때 호출된다. DB 버전이 1에서 4까지 하나씩 올라가면서 스카마와 데이터가 점차 번역되었다고 하자. DB 버전이 1일 때 앱이 DB를 생성한다면 onCreate() 메서드가 호출되고, 중간에 앱을 업데이트하지 않다가 최신 버전으로 업데이트 했다면 `onUpgrade()`메서드가 호출된다. 반면에 버전이 4일 때 처음 앱을 설치한다면 `onCreate()` 메서드만 호출되고 `onUpgrade()` 메서드는 호출되지 않는다. 개발하다보면 onCreate()와 onUpgrade()가 순차적으로 호출된다고 생각하는 경우가 많지만, 둘 둥 하나만 호출된다.  

따라서 최신 DB 스키마와 데이터를 반영할 수 있도록 버전이 올라갈 때마다 onCreate() 메서드를 수정해야 한다.  

그리고 onCreate()와 onUpgrade() 메서드는 테이블을 생성/수정하는 것뿐만 아니라 많은 양의 기본 데이터를 추가하거나 업데이트하는 작업도 필요하다. 이때 속도를 높이기 위해 트랜잭션을 써야할 것 같지만 SQLiteOpenHelper는 이미 onCreate()와 onUpgrade() 메서드를 1개의 트랜잭션으로 감싸놓았다. 따라서 개발자는 트랜잭션 처리를 고려하지 않아도 된다.  

### 5-5. 메모리 DB  

생성자에서 데이터베이스 이름 대신 null을 사용하면 파일 DB가 아닌 메모리 DB가 만들어진다. 메모리 DB는 파일 DB보다 훨씬 빠르고, 프로세스가 종료되거나 DB가 닫히면 사라져버리는 휘발성 DB이므로 일종의 캐시 용도로 사용하기에 적합하다.  

코드상에서 별도로 캐시 자료구조를 만들 수도 있지만 메모리 DB를 사용하면 쿼리를 실행할 수 있는 장점이 있다. 예를 들어, 여러 칼럼이 있고 각 칼럼별로 정렬을 바꾸어주는 기능이 있다면 정렬할 때마다 파일 IO를 하는 것보다는 메모리 DB에 담아놓고서 쿼리로 정렬하는 게 훨씬 빠르다.  

당연한 얘기지만 메모리 DB에서는 DB 버전 업그레이드가 의미가 없으므로 버전은 신경 쓸 필요가 없다.  

### 5-6. 싱글턴  

아까도 살펴본 내용이지만 DB 헬퍼는 앱 전체에 걸쳐 단일 인스턴스를 가지고 있어야 DB 락 문제에서 자유롭다. 그래서 일반적으로 아래와 같이 싱글턴 패턴을 만들어서 사용한다.  

```java
public class DatabaseHelper extends SQLiteOpenHelper {
    private static DatabaseHelper instance;

    public static synchronized DatabaseHelper getInstance(Context context) {
        if (instance == null) {
            instance = new DatabaseHelper(context.getApplicationContext());
        }
        return instance;
    }

    private DatabaseHelper(Context context) {
        ...
    }
}
```  

멀티 스레드 환경에서 동시에 DatabaseHelper.getInstance()를 호출하면 싱글턴을 완전히 보장할 수는 없다. 따라서 DCL(double-checked locking) 등의 장치가 필요하지만 앱 맥락 상 그럴 일이 없을 것 같다는 판단이 들면 위처럼 간단히 구현해도 된다.  

### 5-7. close() 메서드  

`close()` 메서드는 호출할 필요가 거의 없다. SQLiteOpenHelper의 close() 메서드는 SQLiteDatabase 인스턴스의 close()를 호출하고, SQLiteDatabase 인스턴스를 null로 만든다. SQLiteDatabase를 닫지 않고 인스턴스를 계속 사용해도 문제가 없다.  

close() 메서드를 사용하지 않는 또 다른 이유는 close() 실행 시점 때문에 문제가 발생할 수 있기 때문이다. A 스레드에서 `getWritableDatabase()` 이후에 쿼리를 실행한다고 하자. B 스레드에서는 뭔가 작업을 하고 close()를 실행한다. 시점에 따라서 A스레드에서 getWritableDatabase() 이후에 B스레드에서 close()가 실행되고, 이것을 가지고 A스레드에서 쿼리를 실행한다면 NPE가 발생한다.  

### 5-8 onConfigure(), onOpen()  

DB 기능을 변경할 수 있는 메서드는 다음과 같다.

- `onConfigure(SQLiteDatabse db)` : SQLiteDatabase 생성/열기 이후, `onCreate()`와 `onUpgrade()` 메서드 전에 실행되는 것으로 WAL(write-ahead logging)이나 외래 키(foreign key) 지원 같은 기능을 활성화할 수 있다.
- `onOpen(SQLiteDatabase db)` : onCreate()와 onUpgrade() 이후에 DB 연결 설정을 변경할 때 사용한다.  
 










<br>
<br>


--- 
해당 포스팅은 [안드로이드 프로그래밍 Next Step - 노재춘 저](http://www.yes24.com/Product/Goods/41085242) 을 바탕으로 내용을 보충하여 작성되었습니다.

